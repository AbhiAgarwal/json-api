import co from "co";
import polyfill from "babel/polyfill";

import ResponseContext from "./types/Context/ResponseContext";
import Document from "./types/Document";
import Collection from "./types/Collection";
import APIError from "./types/APIError";

import * as requestValidators from "./steps/http/validate-request";
import negotiateContentType from "./steps/http/negotiate-content-type";

import labelToIds from "./steps/pre-query/label-to-ids";
import parseRequestResources from "./steps/pre-query/parse-resources";
import applyTransform from "./steps/apply-transform";

import doFind from "./steps/do-query/do-find";
import doCreate from "./steps/do-query/do-create";
import doUpdate from "./steps/do-query/do-update";
import doDelete from "./steps/do-query/do-delete";


export default function(registry) {
  let supportedExt = ["bulk"];

  /**
   * @param {RequestContext} requestContext The request context that will be
   *    used by the pipeline to generate the ResponseContext for the request.
   * @param {Object} frameworkReq This should be the request object generated by
   *    the framework that you're using. But, really, it can be absolutely
   *    anything, as this pipeline won't use it for anything except passing it
   *    to user-provided functions that it calls (like transforms and id mappers).
   * @param {Object} frameworkRes Theoretically, the response objcet generated
   *     by your http framework but, like with frameworkReq, it can be anything.
   */
  function pipeline(requestContext, frameworkReq, frameworkRes) {
    let responseContext = new ResponseContext();

    // Kick off the chain for generating the response.
    return co(function*() {
      try {
        // throw if the body is supposed to be present but isn't (or vice-versa).
        yield requestValidators.checkBodyExistence(requestContext);

        // If the request has a body, validate it and parse its resources.
        if(requestContext.hasBody) {
          yield requestValidators.checkBodyIsValidJSONAPI(requestContext.body);
          yield requestValidators.checkContentType(requestContext, supportedExt);

          let parsedResources = yield parseRequestResources(
            requestContext.body.data, requestContext.aboutLinkObject
          );
          requestContext.primary = applyTransform(
            parsedResources, "beforeSave", registry, frameworkReq, frameworkRes
          );
        }

        // Map label to idOrIds, if applicable.
        if(requestContext.idOrIds && requestContext.allowLabel) {
          let mappedLabel = yield labelToIds(
            requestContext.type, requestContext.idOrIds, registry, frameworkReq
          );

          // set the idOrIds on the request context
          requestContext.idOrIds = mappedLabel;

          // if our new ids are null/undefined or an empty array, we can set
          // the primary resources too! (Note: one could argue that we should
          // 404 rather than return null when the label matches no ids.)
          let mappedIsEmptyArray = Array.isArray(mappedLabel) && !mappedLabel.length;

          if(mappedLabel === null || mappedLabel === undefined || mappedIsEmptyArray) {
            responseContext.primary = (mappedLabel) ? new Collection() : null;
          }
        }

        // Actually fulfill the request!
        // If we've already populated the primary resources, which is possible
        // because the label may have mapped to no id(s), we don't need to query.
        if(typeof responseContext.primary === "undefined") {
          switch(requestContext.method) {
            case "get":
              yield doFind(requestContext, responseContext, registry);
              break;

            case "post":
              yield doCreate(requestContext, responseContext, registry);
              break;

            case "patch":
              yield doUpdate(requestContext, responseContext, registry);
              break;

            case "delete":
              yield doDelete(requestContext, responseContext, registry);
          }
        }
      }

      // Add errors to the responseContext converting them, if necessary, to
      // APIError instances first. Might be needed if, e.g., the error was
      // unexpected (and so uncaught and not transformed) in one of prior steps
      // or the user couldn't throw an APIError for compatibility with other code.
      catch (errors) {
        errors = (Array.isArray(errors) ? errors : [errors]).map((it) => {
          if(it instanceof APIError) {
            return it;
          }
          else {
            const status = it.status || it.statusCode || 500;
            // if the user can't throw an APIError instance but wants to signal
            // that their specific error message should be used, let them do so.
            const message = it.isJSONAPIDisplayReady ? it.message :
              "An unknown error occurred while trying to process this request.";

            return new APIError(status, undefined, message);
          }
        });
        responseContext.errors = responseContext.errors.concat(errors);
      }

      // Negotiate the content type
      responseContext.contentType = yield negotiateContentType(
        requestContext.accepts, responseContext.ext, supportedExt
      );

      // apply transforms pre-send
      responseContext.primary = applyTransform(
        responseContext.primary, "beforeRender", registry, frameworkReq, frameworkRes
      );

      responseContext.included = applyTransform(
        responseContext.included, "beforeRender", registry, frameworkReq, frameworkRes
      );

      if(responseContext.errors.length) {
        responseContext.status = pickStatus(responseContext.errors.map(
          (v) => Number(v.status)
        ));
        responseContext.body = new Document(responseContext.errors).get();
      }

      else if(responseContext.status !== 204) {
        responseContext.body = new Document(
          responseContext.primary, responseContext.included,
          {}, registry.urlTemplates(), requestContext.uri
        ).get();
      }

      return responseContext;
    });
  }

  pipeline.supportedExt = supportedExt;

  pipeline.responseFromExternalError = function(requestContext, error) {
    let responseContext = new ResponseContext();
    negotiateContentType(requestContext.accepts, [], supportedExt)
      .then((contentType) => {
        responseContext.contentType = contentType;
        responseContext.status = error.status || 400;
        responseContext.body  = (new Document([APIError.fromError(error)])).get();
      }, () => {}
    );
  };

  return pipeline;
}

/**
 * Returns the status code that best represents a set of error statuses.
 */
function pickStatus(errStatuses) {
  return errStatuses[0];
}
