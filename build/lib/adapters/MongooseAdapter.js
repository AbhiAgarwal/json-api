// Generated by LiveScript 1.2.0
(function(){
  var mongoose, utils, Resource, Collection, ErrorResource, advice, Q, MongooseAdapter;
  mongoose = require('mongoose');
  utils = require('mongoose/lib/utils');
  Resource = require('../types/Resource');
  Collection = require('../types/Collection');
  ErrorResource = require('../types/ErrorResource');
  advice = require('../util/advice');
  Q = require('Q');
  MongooseAdapter = (function(){
    MongooseAdapter.displayName = 'MongooseAdapter';
    var prototype = MongooseAdapter.prototype, constructor = MongooseAdapter;
    function MongooseAdapter(model, options){
      this.model = model;
      this.options = options;
      this.refPaths = constructor.getReferencePaths(this.model);
      this.queryBuilder = new mongoose.Query(null, null, this.model, this.model.collection);
    }
    prototype.mode = function(){
      var x$;
      x$ = this.queryBuilder;
      x$[mode]();
      return x$;
    };
    prototype.any = function(){
      var x$;
      x$ = this.queryBuilder;
      x$.find();
      return x$;
    };
    prototype.withId = function(id){
      var x$;
      x$ = this.queryBuilder;
      x$.findOne({
        '_id': id
      });
      return x$;
    };
    prototype.withIds = function(ids){
      var x$;
      x$ = this.queryBuilder;
      x$.find({
        '_id': {
          '$in': ids
        }
      });
      return x$;
    };
    prototype.withProperty = function(prop, val){
      var x$;
      x$ = this.queryBuilder;
      x$.where({
        prop: val
      });
      return x$;
    };
    prototype.onlyFields = function(fields){
      var x$, origAfter;
      x$ = this.queryBuilder;
      x$.select(fields.join(' '));
      if (!in$('id', fields)) {
        origAfter = this.afterQuery;
        this.afterQuery = function(docs){
          var result;
          result = origAfter.apply(this, arguments);
          if (result instanceof Collection) {
            result.resources.map(function(resource){
              return resource.id = void 8;
            });
          } else {
            result.id = void 8;
          }
          return result;
        };
      }
      return this.queryBuilder;
    };
    prototype.limitTo = function(limit){
      var x$;
      x$ = this.queryBuilder;
      x$.limit(limit);
      return x$;
    };
    prototype.includeLinked = function(paths){
      var this$ = this;
      this.refPaths.forEach(function(it){
        var i$, ref$, len$, i, path, pathExtra, x$, results$ = [];
        for (i$ = 0, len$ = (ref$ = paths).length; i$ < len$; ++i$) {
          i = i$;
          path = ref$[i$];
          if (path.substr(0, it.length) === it) {
            pathExtra = path.substr(it.length + 1);
            this$.queryBuilder.populate((x$ = {}, x$.path = it, pathExtra && (x$.select = pathExtra), x$));
            paths.splice(i, 1);
            continue;
          }
        }
        return results$;
      });
      if (paths.length) {
        paths.forEach(function(it){
          return this.queryBuilder.populate({
            path: it
          });
        });
      }
      return this.queryBuilder;
    };
    /**
     * @param sorts array An array of field names to sort on.
     * Ascending is the default sort; prefix the field name with
     * a - to sort descending.
     */
    prototype.sort = function(sorts){
      return this.queryBuilder.sort(sorts.join(' '));
    };
    prototype.promise = function(){
      var qb, p;
      qb = this.queryBuilder;
      p = Q(this.queryBuilder.exec());
      p = p.then(function(it){
        return it;
      }, bind$(this, 'errorHandler'));
      if (/^find/.exec(this.queryBuilder.op)) {
        p = p.then(bind$(this, 'afterQuery'));
      }
      if (/(update|modify|remove)/.exec(this.queryBuilder.op)) {
        p = p.then(bind$(this, 'beforeSave'));
      }
      return p;
    };
    prototype.errorHandler = function(err){
      return new ErrorResource(null, {
        "title": "An error occurred while trying to find, create, or modify the requested resource(s)."
      });
    };
    prototype.afterQuery = function(docs){
      var makeCollection, this$ = this;
      if (!docs) {
        return new ErrorResource(null, {
          status: 404,
          title: "No matching resource found."
        });
      }
      makeCollection = docs instanceof Array;
      if (!makeCollection) {
        docs = [docs];
      }
      docs = docs.map(function(it){
        return constructor.docToResource(it, this$.model.collection.name, this$.refPaths);
      });
      if (makeCollection) {
        return new Collection(docs, null, this.model.collection.name);
      } else {
        return docs[0];
      }
    };
    MongooseAdapter.docToResource = function(doc, type, refPaths){
      var attrs, links;
      attrs = doc.toObject();
      delete attrs['_id'], delete attrs['__v'];
      links = {};
      refPaths.forEach(function(path){
        var pathParts, valAtPath, jsonValAtPath, isToOneRelationship, resources, lastPathPart, containingPathParts, containerVal, ref$, this$ = this;
        pathParts = path.split('.');
        valAtPath = pathParts.reduce(function(obj, part){
          return obj[part];
        }, doc);
        jsonValAtPath = pathParts.reduce(function(obj, part){
          return obj[part];
        }, attrs);
        isToOneRelationship = false;
        if (!(valAtPath instanceof Array)) {
          valAtPath = [valAtPath];
          jsonValAtPath = [jsonValAtPath];
          isToOneRelationship = true;
        }
        resources = [];
        valAtPath.forEach(function(docOrId, i){
          var model, type, id;
          if (docOrId instanceof mongoose.Document) {
            model = docOrId.constructor;
            type = model.collection.name;
            return resources.push(constructor.docToResource(docOrId, type, constructor.getReferencePaths(model)));
          } else {
            id = jsonValAtPath[i];
            type = function(){
              var opts;
              opts = doc.constructor.schema.path(path).options.type;
              if (opts instanceof Array) {
                opts = opts[0];
              }
              return utils.toCollectionName(opts.ref);
            }();
            return resources.push(new Resource(type, id));
          }
        });
        links[path] = isToOneRelationship
          ? resources[0]
          : new Collection(resources);
        lastPathPart = pathParts[pathParts.length - 1];
        containingPathParts = pathParts.slice(0, pathParts.length - 1);
        containerVal = containingPathParts.reduce(function(obj, part){
          return obj[part];
        }, attrs);
        return ref$ = containerVal[lastPathPart], delete containerVal[lastPathPart], ref$;
      });
      return new Resource(type, doc.id, attrs, refPaths.length ? links : void 8);
    };
    MongooseAdapter.getReferencePaths = function(model){
      var paths, this$ = this;
      paths = [];
      model.schema.eachPath(function(name, type){
        var toCheck;
        toCheck = type.options.type;
        if (toCheck instanceof Array) {
          toCheck = toCheck[0];
        }
        if (typeof toCheck === "object" && toCheck.ref) {
          return paths.push(name);
        }
      });
      return paths;
    };
    return MongooseAdapter;
  }());
  module.exports = MongooseAdapter;
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
}).call(this);
