// Generated by LiveScript 1.2.0
(function(){
  var Q, mongoose, Document, Collection, ErrorResource;
  Q = require('Q');
  mongoose = require('mongoose');
  Document = require('./types/Document');
  Collection = require('./types/Collection');
  ErrorResource = require('./types/ErrorResource');
  module.exports = {
    /**
     * Returns an object with newProps as properties (all enumerable) 
     * and values and `this` in the prototype chain. Allows you create
     * controllers that extend this one.
     */
    extend: function(newProps){
      var k, v;
      return Object.create(this, (function(){
        var ref$, own$ = {}.hasOwnProperty, results$ = {};
        for (k in ref$ = newProps) if (own$.call(ref$, k)) {
          v = ref$[k];
          results$[k] = {
            value: v,
            enumerable: true
          };
        }
        return results$;
      }()));
    }
    /**
     * A function that, when called, returns a new object that implements 
     * the Adapter interface. Should be provided by the child controller.
     * Whe need to get a new adapter on each request so the query state is
     * specific to this request (since the controller objects themselves
     * persist between requests).
     */,
    adapterFn: null,
    _buildQuery: function(req){
      var query, ids;
      query = this.adapterFn();
      switch (req.method.toUpperCase()) {
      case "GET":
        if (req.params.id) {
          ids = req.params.id.split(",");
          if (ids.length > 1) {
            query.withIds(ids);
          } else {
            query.withId(ids[0]);
          }
        } else {
          query.any();
        }
        if (req.query.sort) {
          query.sort(req.query.sort.split(','));
        }
        if (req.query.fields) {
          query.onlyFields(req.query.fields.split(','));
        }
        query.limitTo(100);
        break;
      case "POST":
      }
      return query;
    },
    GET: function(req, res, next){
      var after;
      after = bind$(this, 'afterQuery');
      return this._buildQuery(req).promise().then(function(result){
        if (result instanceof Collection) {
          result.resources.map(function(it){
            return after(it, req, res);
          });
          return result;
        } else {
          return after(result, req, res);
        }
      }).then(function(resources){
        return constructor.sendResources(res, resources);
      })['catch'](function(err){
        var er;
        er = ErrorResource.fromError(err);
        return constructor.sendResources(res, er.status, er);
      });
    },
    POST: function(req, res, next){
      var before;
      before = bind$(this, 'beforeSave');
      return this._buildQuery(req).promise().then(function(){}, function(){});
    },
    sendResources: function(res, resources, meta){
      var status;
      if (deepEq$(resources.type, "errors", '===')) {
        if (resources instanceof Collection) {
          status = resources.resources[0].attrs.status;
        } else {
          status = resources.attrs.status;
        }
      } else {
        status = 200;
      }
      return res.json(status, new Document(resources, meta).get());
    }
  };
  /*
  
  
     * Returns a promise for all model instances in the
     * collection associated with this.model.
    
    manyMongooseDocsPromise: function(query, limit) {
      if(typeof query === 'number') {
        limit = query;
      }
      query = (query instanceof Array && query.length) ? {_id: {$in: query}} : {};
  
      return Q(this.model.find(query).limit(limit || 1000).exec());
    },
  
    
     * Preps a Mongoose model to be returned as a resource
     * in a JSON-API-compliant response (http://jsonapi.org/).
    
    mongooseDocToJsonApiResource: function(doc) {
      var resource = doc.toObject();
  
      this.model.schema.eachPath(function(path, type) {
        //add all properties from the schema, including sub-docs,
        //to the resource. Still need to figure out relations.
        var splitPath = path.split('.')
          , currLevel = resource;
  
        for(var i = 0, len = splitPath.length - 1; i<len; i++) {
          currLevel[splitPath[i]] = currLevel[splitPath[i]] || {};
          currLevel = currLevel[splitPath[i]];
        }
        currLevel[splitPath[len]] = doc.get(path);
      });
  
      resource.id = doc._id;
      delete resource._id;
      delete resource.__v;
  
      return resource;
    },
  
    mongooseDocsToJsonApiResponse: function(mongooseDocs) {
      var collectionName = pluralize.plural(this.model.modelName).toLowerCase()
        , resources      = (mongooseDocs instanceof Array) ? 
            mongooseDocs.map(this.mongooseDocToJsonApiResource.bind(this)) : 
            this.mongooseDocToJsonApiResource(mongooseDocs);
  
      return JsonApi.attachResources(collectionName, resources);
    },
  
    sendJsonApiError: function(err, res) {
      var errors, thisError, generatedError;
  
      //convert mongoose errors
      if(err.errors) {
        errors = [];
        for(var key in err.errors) {
          thisError = err.errors[key];
          generatedError = {
            status: (err.name == "ValidationError" ? 400 : (thisError.status || 500))
          };
  
          switch(thisError.type) {
            case "required":
            default:
              generatedError.title = thisError.message;
          };
  
          if(thisError.path) {
            generatedError.path = thisError.path;
          }
          errors.push(generatedError);
        }
  
        errors.status = err.status || (err.name == "ValidationError" ? 400 : 500);
        return JsonApi.sendError(errors, res);
      }
      
      JsonApi.sendError(err, res);
    },
  
    fulfillList: function(res, next) {
      var self = this;
  
    },
  
    fulfillRead: function(req, res, next, customModelResolver) {
      var self = this;
  
      this.mongooseDocFromIdsPromise(req, customModelResolver)
        .then(function(docs) {
          res.json(self.mongooseDocsToJsonApiResponse(docs));
        }).catch(function(err) {
          self.sendJsonApiError(err, res);
        });
    },
  
    fulfillCreate: function(req, res, next, urlFor, readRouteName) {
      var self = this;
      this.model.create(req.body).then(function(newModel) {
        res.status(201);
        res.location(urlFor(readRouteName, {params: {id: newModel.id}}));
        res.send(self.mongooseDocsToJsonApiResponse(newModel));
      }, function(err) { self.sendJsonApiError(err, res); });
    },
  
    fulfillUpdate: function(req, res, next, customUpdateFunction, customModelResolver) {
      var self = this
        , updateFunction;    
      if(typeof customUpdateFunction === "function") {
        updateFunction = customUpdateFunction;
      } 
      else {
        updateFunction = function(doc) {
          for(var key in req.body) {
            doc[key] = req.body[key];
          }
          return doc;
        };
      }
      //200 status code + resource, rather than a 204,
      //is ok (actually, required) because we're updating
      //the modified date field on each PUT.
      this.mongooseDocFromIdsPromise(req, customModelResolver)
        .then(
          updateFunction
        ).then(function(doc) {
          return Q.nfcall(doc.save);
        })
        .spread(
          this.mongooseDocToJsonApiResource
        ).then(
          res.json.bind(res)
        ).catch(function(err) { 
          self.sendJsonApiError(err, res);
        });
    },
  
    fulfillDelete: function(req, res, next, customModelResolver) {
      this.mongooseDocFromIdsPromise(req, customModelResolver).then(function(docs) {
        if(!(docs instanceof Array)) {
          docs = [docs];
        }
        return Q.all(docs.map(function(doc) { return Q.nfcall(doc.remove.bind(doc)); }));
      }).then(function() {
        res.status(204);
        res.send();
      }).catch(function(err) { self.sendJsonApiError(err, res); });
    } 
  };*/
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
  function deepEq$(x, y, type){
    var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,
        has = function (obj, key) { return hasOwnProperty.call(obj, key); };
    var first = true;
    return eq(x, y, []);
    function eq(a, b, stack) {
      var className, length, size, result, alength, blength, r, key, ref, sizeB;
      if (a == null || b == null) { return a === b; }
      if (a.__placeholder__ || b.__placeholder__) { return true; }
      if (a === b) { return a !== 0 || 1 / a == 1 / b; }
      className = toString.call(a);
      if (toString.call(b) != className) { return false; }
      switch (className) {
        case '[object String]': return a == String(b);
        case '[object Number]':
          return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
        case '[object Date]':
        case '[object Boolean]':
          return +a == +b;
        case '[object RegExp]':
          return a.source == b.source &&
                 a.global == b.global &&
                 a.multiline == b.multiline &&
                 a.ignoreCase == b.ignoreCase;
      }
      if (typeof a != 'object' || typeof b != 'object') { return false; }
      length = stack.length;
      while (length--) { if (stack[length] == a) { return true; } }
      stack.push(a);
      size = 0;
      result = true;
      if (className == '[object Array]') {
        alength = a.length;
        blength = b.length;
        if (first) { 
          switch (type) {
          case '===': result = alength === blength; break;
          case '<==': result = alength <= blength; break;
          case '<<=': result = alength < blength; break;
          }
          size = alength;
          first = false;
        } else {
          result = alength === blength;
          size = alength;
        }
        if (result) {
          while (size--) {
            if (!(result = size in a == size in b && eq(a[size], b[size], stack))){ break; }
          }
        }
      } else {
        if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) {
          return false;
        }
        for (key in a) {
          if (has(a, key)) {
            size++;
            if (!(result = has(b, key) && eq(a[key], b[key], stack))) { break; }
          }
        }
        if (result) {
          sizeB = 0;
          for (key in b) {
            if (has(b, key)) { ++sizeB; }
          }
          if (first) {
            if (type === '<<=') {
              result = size < sizeB;
            } else if (type === '<==') {
              result = size <= sizeB
            } else {
              result = size === sizeB;
            }
          } else {
            first = false;
            result = size === sizeB;
          }
        }
      }
      stack.pop();
      return result;
    }
  }
}).call(this);
