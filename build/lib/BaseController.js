// Generated by LiveScript 1.2.0
(function(){
  var Q, mongoose, Document, Collection, ErrorResource, bodyParser;
  Q = require('Q');
  mongoose = require('mongoose');
  Document = require('./types/Document');
  Collection = require('./types/Collection');
  ErrorResource = require('./types/ErrorResource');
  bodyParser = require('body-parser');
  module.exports = {
    /**
     * Keeps a collection of all objects extending this one, indexed by type.
     * Used to run the beforeSave/afterQuery methods from the controllers of
     * linked resources. E.g. if a subclass is a User controller w/ beforeSave
     * and afterQuery methods, it may be that a User also has some Projects,
     * and we want a request for /users?include=projects to be able to run
     * the beforeSave and afterQuery methods from the Projects controller before
     * returning.
     */
    subclasses: {},
    jsonBodyParser: bodyParser.json({
      type: ['json', 'application/vnd.api+json']
    })
    /**
     * Returns an object extending this class, and registers the subclass.
     * By registering, I mean it adds the subclass to {@subclasses}, replaces its
     * urlTemplates with a reference to the shared urlTemplates object (after
     * merging in the subclass' additions), and sets type as a property on the 
     * new instance. By extending this class, I mean that the subclass will have
     * newProps as properties/values on it (all enumerable) and BaseController in
     * its prototype chain.
     */,
    extend: function(type, newProps){
      var path, ref$, template, k, v;
      for (path in ref$ = newProps.urlTemplates) {
        template = ref$[path];
        this.urlTemplates[path] = template;
      }
      delete newProps.urlTemplates;
      newProps.type = type;
      this.subclasses[type] = Object.create(this, (function(){
        var ref$, own$ = {}.hasOwnProperty, results$ = {};
        for (k in ref$ = newProps) if (own$.call(ref$, k)) {
          v = ref$[k];
          results$[k] = {
            value: v,
            enumerable: true
          };
        }
        return results$;
      }()));
      return this.subclasses[type];
    }
    /**
     * A function that, when called, returns a new object that implements 
     * the Adapter interface. Should be provided by the child controller.
     * We need to get a new adapter on each request so the query state is
     * specific to this request (since the controller objects themselves
     * persist between requests).
     */,
    adapterFn: null
    /**
     * A urlTemplates object shared by all controllers.
     * If subclasses are created through {@extend}, their urlTemplates
     * will be merged into this rather than shading it, so a controller 
     * that extends BaseController will have access to the urlTemplates 
     * registered by another controller that extends it.
     */,
    urlTemplates: {},
    _pickStatus: function(errStatuses){
      return errStatuses[0];
    },
    GET: function(req, res, next){
      var query, ids, filters, attr, val, this$ = this;
      query = this.adapterFn();
      if (req.params.id) {
        ids = req.params.id.split(",").map(decodeURIComponent);
        if (ids.length > 1) {
          query.withIds(ids);
        } else {
          query.withId(ids[0]);
        }
      } else {
        query.any();
      }
      if (req.query.sort != null) {
        query.sort(req.query.sort.split(','));
      }
      if (req.query.fields != null) {
        query.onlyFields(req.query.fields.split(','));
      }
      if (req.query.include != null) {
        query.includeLinked(req.query.include.split(','));
      }
      filters = import$({}, req.query);
      delete filters['fields'], delete filters['include'], delete filters['sort'];
      for (attr in filters) {
        val = filters[attr];
        if (/^fields\[.+?\]$/.exec(attr)) {
          continue;
        }
        if (val) {
          query.withProperty(attr, val);
        }
      }
      query.limitTo(100);
      return query.promise().then(function(it){
        return this$._afterQueryRecursive(it, req, res);
      }).then(function(resources){
        return this$.sendResources(res, resources);
      })['catch'](function(err){
        var er;
        er = ErrorResource.fromError(err);
        return this$.sendResources(res, er);
      });
    }
    /**
     * Takes a Resource or Collection being returned and applies the
     * appropriate afterQuery method to it and (recursively)
     * to all of its linked resources.
     */,
    _afterQueryRecursive: function(resourceOrCollection, req, res){
      var this$ = this;
      if (resourceOrCollection instanceof Collection) {
        resourceOrCollection.resources.map(function(it){
          return this$._after(it, req, res);
        });
        return resourceOrCollection;
      } else {
        return this._after(resourceOrCollection, req, res);
      }
    }
    /** 
     * A helper function for {@_afterQueryRecursive}.
     *
     * @api private
     */,
    _after: function(resource, req, res){
      var path, ref$, linked;
      if (typeof this.subclasses[resource.type].afterQuery === 'function') {
        resource = bind$(this.subclasses[resource.type], 'afterQuery')(resource, req, res);
      }
      for (path in ref$ = resource.links) {
        linked = ref$[path];
        resource.links[path] = this._afterQueryRecursive(resource.links[path], req, res);
      }
      return resource;
    },
    _getBodyPromise: function(req, res){
      if (typeof req.body !== "object") {
        return Q.nfapply(this.jsonBodyParser, [req, res]).then(function(){
          return req.body;
        }, function(err){
          switch (err.message) {
          case /encoding unsupported/i:
            throw new ErrorResource(null, {
              title: err.message,
              status: err.status
            });
          case /empty body/i:
            req.body = null;
            return req.body;
          case /invalid json/i:
            throw new ErrorResource(null, {
              title: "Request contains invalid JSON.",
              status: 400
            });
          default:
            if (err instanceof SyntaxError) {
              err.title = "Request contains invalid JSON.";
            }
            throw ErrorResource.fromError(err);
          }
        });
      } else {
        return Q.fcall(function(){
          return req.body;
        });
      }
    },
    POST: function(req, res, next){
      var this$ = this;
      if (req.is('application/vnd.api+json') === false) {
        return next();
      }
      return this._getBodyPromise(req, res).then(function(body){
        var resources, query;
        resources = body && (body[this$.type] || body.data);
        if (!resources || (resources instanceof Array && !resources.length)) {
          throw new ErrorResource(null, {
            title: "Request must contain a resource or an array of resources to create.",
            detail: "This resource or array of resources should be stored at the top-level document's `" + this$.type + "` or `data` key.",
            status: 400
          });
        }
        return query = this$.adapterFn().create(body).promise().then(function(created){
          return res.send(201);
        }, function(err){});
      }).then(function(created){
        return this.sendResources(res, created);
      }, function(errorResource){
        return this$.sendResources(res, errorResource);
      });
    },
    PUT: function(req, res, next){
      if (!req.is('application/vnd.api+json')) {
        return next();
      }
    },
    sendResources: function(res, resources, meta){
      var status;
      if (resources.type === "errors") {
        if (resources instanceof Collection) {
          status = this._pickStatus(resources.resources.map(function(it){
            return Number(it.attrs.status);
          }));
        } else {
          status = resources.attrs.status;
        }
      } else {
        status = 200;
      }
      res.set('Content-Type', 'application/vnd.api+json');
      return res.json(Number(status), new Document(resources, meta, this.urlTemplates).get());
    }
  };
  /*
    sendJsonApiError: function(err, res) {
      var errors, thisError, generatedError;
  
      //convert mongoose errors
      if(err.errors) {
        errors = [];
        for(var key in err.errors) {
          thisError = err.errors[key];
          generatedError = {
            status: (err.name == "ValidationError" ? 400 : (thisError.status || 500))
          };
  
          switch(thisError.type) {
            case "required":
            default:
              generatedError.title = thisError.message;
          };
  
          if(thisError.path) {
            generatedError.path = thisError.path;
          }
          errors.push(generatedError);
        }
  
        errors.status = err.status || (err.name == "ValidationError" ? 400 : 500);
        return JsonApi.sendError(errors, res);
      }
      
      JsonApi.sendError(err, res);
    },
  
    fulfillCreate: function(req, res, next, urlFor, readRouteName) {
      var self = this;
      this.model.create(req.body).then(function(newModel) {
        res.status(201);
        res.location(urlFor(readRouteName, {params: {id: newModel.id}}));
        res.send(self.mongooseDocsToJsonApiResponse(newModel));
      }, function(err) { self.sendJsonApiError(err, res); });
    },
  
    fulfillUpdate: function(req, res, next, customUpdateFunction, customModelResolver) {
      var self = this
        , updateFunction;    
      if(typeof customUpdateFunction === "function") {
        updateFunction = customUpdateFunction;
      } 
      else {
        updateFunction = function(doc) {
          for(var key in req.body) {
            doc[key] = req.body[key];
          }
          return doc;
        };
      }
      //200 status code + resource, rather than a 204,
      //is ok (actually, required) because we're updating
      //the modified date field on each PUT.
      this.mongooseDocFromIdsPromise(req, customModelResolver)
        .then(
          updateFunction
        ).then(function(doc) {
          return Q.nfcall(doc.save);
        })
        .spread(
          this.mongooseDocToJsonApiResource
        ).then(
          res.json.bind(res)
        ).catch(function(err) { 
          self.sendJsonApiError(err, res);
        });
    },
  
    fulfillDelete: function(req, res, next, customModelResolver) {
      this.mongooseDocFromIdsPromise(req, customModelResolver).then(function(docs) {
        if(!(docs instanceof Array)) {
          docs = [docs];
        }
        return Q.all(docs.map(function(doc) { return Q.nfcall(doc.remove.bind(doc)); }));
      }).then(function() {
        res.status(204);
        res.send();
      }).catch(function(err) { self.sendJsonApiError(err, res); });
    } 
  };*/
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
}).call(this);
