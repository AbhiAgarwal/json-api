// Generated by LiveScript 1.2.0
(function(){
  var Q, mongoose, Document, Collection, ErrorResource;
  Q = require('Q');
  mongoose = require('mongoose');
  Document = require('./types/Document');
  Collection = require('./types/Collection');
  ErrorResource = require('./types/ErrorResource');
  module.exports = {
    /**
     * Returns an object with newProps as properties (all enumerable) 
     * and values and `this` in the prototype chain. Allows you create
     * controllers that extend this one.
     */
    extend: function(newProps){
      var k, v;
      return Object.create(this, (function(){
        var ref$, own$ = {}.hasOwnProperty, results$ = {};
        for (k in ref$ = newProps) if (own$.call(ref$, k)) {
          v = ref$[k];
          results$[k] = {
            value: v,
            enumerable: true
          };
        }
        return results$;
      }()));
    }
    /**
     * A function run on each resource returned from a query to transform it.
     * Subclasses should replace this with their own implementation
     */,
    afterQuery: function(it){
      return it;
    }
    /**
     * A function run on each resource before it's saved.
     * Subclasses should replace this with their own implementation
     */,
    beforeSave: function(it){
      return it;
    }
    /**
     * A function that, when called, returns a new object that implements 
     * the Adapter interface. Should be provided by the child controller.
     * Whe need to get a new adapter on each request so the query state is
     * specific to this request (since the controller objects themselves
     * persist between requests).
     */,
    adapterFn: null
    /** Another stub for child controllers to override */,
    urlTemplates: {},
    _pickStatus: function(errStatuses){
      return errStatuses[0];
    },
    _buildQuery: function(req){
      var query, ids, filters, attr, val;
      query = this.adapterFn();
      switch (req.method.toUpperCase()) {
      case "GET":
        if (req.params.id) {
          ids = req.params.id.split(",");
          if (ids.length > 1) {
            query.withIds(ids);
          } else {
            query.withId(ids[0]);
          }
        } else {
          query.any();
        }
        if (req.query.sort) {
          query.sort(req.query.sort.split(','));
        }
        if (req.query.fields) {
          query.onlyFields(req.query.fields.split(','));
        }
        if (req.query.include) {
          query.includeLinked(req.query.include.split(','));
        }
        filters = import$({}, req.query);
        delete filters['fields'], delete filters['include'], delete filters['sort'];
        for (attr in filters) {
          val = filters[attr];
          if (/^fields\[.+?\]$/.exec(attr)) {
            continue;
          }
          if (val) {
            query.withProperty(attr, val);
          }
        }
        query.limitTo(100);
        break;
      case "POST":
      }
      return query;
    },
    GET: function(req, res, next){
      var after, this$ = this;
      after = bind$(this, 'afterQuery');
      return this._buildQuery(req).promise().then(function(result){
        if (result instanceof Collection) {
          result.resources.map(function(it){
            return after(it, req, res);
          });
          return result;
        } else {
          return after(result, req, res);
        }
      }).then(function(resources){
        return this$.sendResources(res, resources);
      })['catch'](function(err){
        var er;
        er = ErrorResource.fromError(err);
        return this$.sendResources(res, er);
      });
    },
    POST: function(req, res, next){
      var before;
      before = bind$(this, 'beforeSave');
      return this._buildQuery(req).promise().then(function(){}, function(){});
    },
    sendResources: function(res, resources, meta){
      var status;
      if (resources.type === "errors") {
        if (resources instanceof Collection) {
          status = this._pickStatus(resources.resources.map(function(it){
            return Number(it.attrs.status);
          }));
        } else {
          status = resources.attrs.status;
        }
      } else {
        status = 200;
      }
      res.set('Content-Type', 'application/vnd.api+json');
      return res.json(Number(status), new Document(resources, meta, this.urlTemplates).get());
    }
  };
  /*
  
    mongooseDocsToJsonApiResponse: function(mongooseDocs) {
      var collectionName = pluralize.plural(this.model.modelName).toLowerCase()
        , resources      = (mongooseDocs instanceof Array) ? 
            mongooseDocs.map(this.mongooseDocToJsonApiResource.bind(this)) : 
            this.mongooseDocToJsonApiResource(mongooseDocs);
  
      return JsonApi.attachResources(collectionName, resources);
    },
  
    sendJsonApiError: function(err, res) {
      var errors, thisError, generatedError;
  
      //convert mongoose errors
      if(err.errors) {
        errors = [];
        for(var key in err.errors) {
          thisError = err.errors[key];
          generatedError = {
            status: (err.name == "ValidationError" ? 400 : (thisError.status || 500))
          };
  
          switch(thisError.type) {
            case "required":
            default:
              generatedError.title = thisError.message;
          };
  
          if(thisError.path) {
            generatedError.path = thisError.path;
          }
          errors.push(generatedError);
        }
  
        errors.status = err.status || (err.name == "ValidationError" ? 400 : 500);
        return JsonApi.sendError(errors, res);
      }
      
      JsonApi.sendError(err, res);
    },
  
    fulfillCreate: function(req, res, next, urlFor, readRouteName) {
      var self = this;
      this.model.create(req.body).then(function(newModel) {
        res.status(201);
        res.location(urlFor(readRouteName, {params: {id: newModel.id}}));
        res.send(self.mongooseDocsToJsonApiResponse(newModel));
      }, function(err) { self.sendJsonApiError(err, res); });
    },
  
    fulfillUpdate: function(req, res, next, customUpdateFunction, customModelResolver) {
      var self = this
        , updateFunction;    
      if(typeof customUpdateFunction === "function") {
        updateFunction = customUpdateFunction;
      } 
      else {
        updateFunction = function(doc) {
          for(var key in req.body) {
            doc[key] = req.body[key];
          }
          return doc;
        };
      }
      //200 status code + resource, rather than a 204,
      //is ok (actually, required) because we're updating
      //the modified date field on each PUT.
      this.mongooseDocFromIdsPromise(req, customModelResolver)
        .then(
          updateFunction
        ).then(function(doc) {
          return Q.nfcall(doc.save);
        })
        .spread(
          this.mongooseDocToJsonApiResource
        ).then(
          res.json.bind(res)
        ).catch(function(err) { 
          self.sendJsonApiError(err, res);
        });
    },
  
    fulfillDelete: function(req, res, next, customModelResolver) {
      this.mongooseDocFromIdsPromise(req, customModelResolver).then(function(docs) {
        if(!(docs instanceof Array)) {
          docs = [docs];
        }
        return Q.all(docs.map(function(doc) { return Q.nfcall(doc.remove.bind(doc)); }));
      }).then(function() {
        res.status(204);
        res.send();
      }).catch(function(err) { self.sendJsonApiError(err, res); });
    } 
  };*/
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
}).call(this);
