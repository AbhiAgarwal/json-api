// Generated by LiveScript 1.2.0
(function(){
  var Q, mongoose, Document, Collection, ErrorResource;
  Q = require('Q');
  mongoose = require('mongoose');
  Document = require('./types/Document');
  Collection = require('./types/Collection');
  ErrorResource = require('./types/ErrorResource');
  module.exports = {
    /**
     * Keeps a collection of all objects extending this one, indexed by type.
     * Used to run the beforeSave/afterQuery methods from the controllers of
     * linked resources. E.g. if a subclass is a User controller w/ beforeSave
     * and afterQuery methods, it may be that a User also has some Projects,
     * and we want a request for /users?include=projects to be able to run
     * the beforeSave and afterQuery methods from the Projects controller before
     * returning.
     */
    subclasses: {}
    /**
     * Returns an object extending this class, and registers the subclass.
     * By registering, I mean it adds the subclass to {@subclasses} and replaces
     * its urlTemplates with a reference to the shared urlTemplates object (after
     * merging in the subclass' additions). By extending this class, I mean
     * that the subclass will have newProps as properties/values on it (all
     * enumerable) and BaseController in its prototype chain.
     */,
    extend: function(type, newProps){
      var path, ref$, template, k, v;
      for (path in ref$ = newProps.urlTemplates) {
        template = ref$[path];
        this.urlTemplates[path] = template;
      }
      delete newProps.urlTemplates;
      this.subclasses[type] = Object.create(this, (function(){
        var ref$, own$ = {}.hasOwnProperty, results$ = {};
        for (k in ref$ = newProps) if (own$.call(ref$, k)) {
          v = ref$[k];
          results$[k] = {
            value: v,
            enumerable: true
          };
        }
        return results$;
      }()));
      return this.subclasses[type];
    }
    /**
     * A function run on each resource returned from a query to transform it.
     * Subclasses should replace this with their own implementation
     */,
    afterQuery: function(it){
      return it;
    }
    /**
     * A function run on each resource before it's saved.
     * Subclasses should replace this with their own implementation
     */,
    beforeSave: function(it){
      return it;
    }
    /**
     * A function that, when called, returns a new object that implements 
     * the Adapter interface. Should be provided by the child controller.
     * We need to get a new adapter on each request so the query state is
     * specific to this request (since the controller objects themselves
     * persist between requests).
     */,
    adapterFn: null
    /**
     * A urlTemplates object shared by all controllers.
     * If subclasses are created through {@extend}, their urlTemplates
     * will be merged into this rather than shading it, so a controller 
     * that extends BaseController will have access to the urlTemplates 
     * registered by another controller that extends it.
     */,
    urlTemplates: {},
    _pickStatus: function(errStatuses){
      return errStatuses[0];
    }
    /**
     * Takes a Resource or Collection being returned and applies the
     * appropriate afterQuery method to it and (recursively)
     * to all of its linked resources.
     */,
    _afterQueryRecursive: function(queryResult){
      var after;
      after = bind$(this, 'afterQuery');
      if (queryResult instanceof Collection) {
        queryResult.resources.map(function(it){
          return after(it, req, res);
        });
        return queryResult;
      } else {
        return after(queryResult, req, res);
      }
    },
    _buildQuery: function(req){
      var query;
      query = this.adapterFn();
      switch (req.method.toUpperCase()) {
      case "POST":
      }
      return query;
    },
    _buildGETQuery: function(req){
      var query, ids, filters, attr, val;
      query = this.adapterFn();
      if (req.params.id) {
        ids = req.params.id.split(",");
        if (ids.length > 1) {
          query.withIds(ids);
        } else {
          query.withId(ids[0]);
        }
      } else {
        query.any();
      }
      if (req.query.sort != null) {
        query.sort(req.query.sort.split(','));
      }
      if (req.query.fields != null) {
        query.onlyFields(req.query.fields.split(','));
      }
      if (req.query.include != null) {
        query.includeLinked(req.query.include.split(','));
      }
      filters = import$({}, req.query);
      delete filters['fields'], delete filters['include'], delete filters['sort'];
      for (attr in filters) {
        val = filters[attr];
        if (/^fields\[.+?\]$/.exec(attr)) {
          continue;
        }
        if (val) {
          query.withProperty(attr, val);
        }
      }
      query.limitTo(100);
      return query;
    },
    GET: function(req, res, next){
      var this$ = this;
      return this._buildGETQuery(req).promise().then(bind$(this, '_afterQueryRecursive')).then(function(resources){
        return this$.sendResources(res, resources);
      })['catch'](function(err){
        var er;
        er = ErrorResource.fromError(err);
        return this$.sendResources(res, er);
      });
    },
    POST: function(req, res, next){
      var err, before;
      if (!req.is('application/vnd.api+json')) {
        return next();
      }
      if (typeof req.body !== "object") {
        try {
          req.body = JSON.parse(req.body);
        } catch (e$) {
          err = e$;
          return this.sendResources(res, ErrorResource.fromError({
            title: "Request contains invalid JSON.",
            details: err.message,
            status: 400
          }));
        }
      }
      return before = bind$(this, 'beforeSave');
    },
    PUT: function(req, res, next){
      var before;
      if (!req.is('application/vnd.api+json')) {
        return next();
      }
      before = bind$(this, 'beforeSave');
      return this._buildQuery(req).promise().then(function(){}, function(){});
    },
    sendResources: function(res, resources, meta){
      var status;
      if (resources.type === "errors") {
        if (resources instanceof Collection) {
          status = this._pickStatus(resources.resources.map(function(it){
            return Number(it.attrs.status);
          }));
        } else {
          status = resources.attrs.status;
        }
      } else {
        status = 200;
      }
      res.set('Content-Type', 'application/vnd.api+json');
      return res.json(Number(status), new Document(resources, meta, this.urlTemplates).get());
    }
  };
  /*
    sendJsonApiError: function(err, res) {
      var errors, thisError, generatedError;
  
      //convert mongoose errors
      if(err.errors) {
        errors = [];
        for(var key in err.errors) {
          thisError = err.errors[key];
          generatedError = {
            status: (err.name == "ValidationError" ? 400 : (thisError.status || 500))
          };
  
          switch(thisError.type) {
            case "required":
            default:
              generatedError.title = thisError.message;
          };
  
          if(thisError.path) {
            generatedError.path = thisError.path;
          }
          errors.push(generatedError);
        }
  
        errors.status = err.status || (err.name == "ValidationError" ? 400 : 500);
        return JsonApi.sendError(errors, res);
      }
      
      JsonApi.sendError(err, res);
    },
  
    fulfillCreate: function(req, res, next, urlFor, readRouteName) {
      var self = this;
      this.model.create(req.body).then(function(newModel) {
        res.status(201);
        res.location(urlFor(readRouteName, {params: {id: newModel.id}}));
        res.send(self.mongooseDocsToJsonApiResponse(newModel));
      }, function(err) { self.sendJsonApiError(err, res); });
    },
  
    fulfillUpdate: function(req, res, next, customUpdateFunction, customModelResolver) {
      var self = this
        , updateFunction;    
      if(typeof customUpdateFunction === "function") {
        updateFunction = customUpdateFunction;
      } 
      else {
        updateFunction = function(doc) {
          for(var key in req.body) {
            doc[key] = req.body[key];
          }
          return doc;
        };
      }
      //200 status code + resource, rather than a 204,
      //is ok (actually, required) because we're updating
      //the modified date field on each PUT.
      this.mongooseDocFromIdsPromise(req, customModelResolver)
        .then(
          updateFunction
        ).then(function(doc) {
          return Q.nfcall(doc.save);
        })
        .spread(
          this.mongooseDocToJsonApiResource
        ).then(
          res.json.bind(res)
        ).catch(function(err) { 
          self.sendJsonApiError(err, res);
        });
    },
  
    fulfillDelete: function(req, res, next, customModelResolver) {
      this.mongooseDocFromIdsPromise(req, customModelResolver).then(function(docs) {
        if(!(docs instanceof Array)) {
          docs = [docs];
        }
        return Q.all(docs.map(function(doc) { return Q.nfcall(doc.remove.bind(doc)); }));
      }).then(function() {
        res.status(204);
        res.send();
      }).catch(function(err) { self.sendJsonApiError(err, res); });
    } 
  };*/
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
