// Generated by LiveScript 1.2.0
(function(){
  var Resource, Collection, prelude, templating, flat, Document;
  Resource = require('./Resource');
  Collection = require('./Collection');
  prelude = require('prelude-ls');
  templating = require('url-template');
  flat = require('flat');
  Document = (function(){
    Document.displayName = 'Document';
    var prototype = Document.prototype, constructor = Document;
    function Document(resources, meta, urlTemplates){
      var res$, k, ref$, template;
      this.resources = resources;
      this.meta = meta;
      this.urlTemplates = urlTemplates;
      this.linked = {};
      this.links = {};
      res$ = {};
      for (k in ref$ = this.urlTemplates) {
        template = ref$[k];
        res$[k] = templating.parse(template);
      }
      this._urlTemplatesParsed = res$;
    }
    prototype.addLinkedResource = function(resource){
      if (this.linked[resource.type] == null) {
        this.linked[resource.type] = [];
      }
      if (!in$(resource.id, this.linked[resource.type].map(function(it){
        return it.id;
      }))) {
        return this.linked[resource.type].push(this.renderResource(resource));
      }
    };
    prototype.renderResource = function(resource){
      var res, urlTempParams, path, ref$, referenced, isCollection, referencedResources, idKey, x$, this$ = this;
      res = resource.attrs;
      if (resource.id) {
        res.id = resource.id;
      }
      urlTempParams = function(){
        return import$({}, res);
      }();
      if (resource.links != null) {
        res.links = {};
      }
      for (path in ref$ = resource.links) {
        referenced = ref$[path];
        isCollection = referenced instanceof Collection;
        referencedResources = isCollection
          ? referenced.resources
          : [referenced];
        idKey = isCollection ? 'ids' : 'id';
        if (!referencedResources[0]) {
          continue;
        }
        x$ = res.links[path] = {};
        x$['type'] = referenced.type;
        x$[idKey] = referenced[idKey];
        if (referencedResources[0].attrs == null) {
          x$['href'] = referenced.href || this.urlFor(resource.type, path, referenced[idKey], urlTempParams);
        }
        referencedResources.forEach(fn$);
      }
      return res;
      function fn$(it){
        if (it.attrs != null) {
          return this$.addLinkedResource(it);
        }
      }
    };
    prototype.urlFor = function(type, path, referencedIdOrIds, extraParams){
      var params, k, v;
      if (!this._urlTemplatesParsed[type + '.' + path]) {
        throw new Error("Missing url template for " + type + '.' + path);
      }
      params = flat.flatten((function(){
        var ref$, results$ = {};
        for (k in ref$ = extraParams) {
          v = ref$[k];
          results$[type + '.' + k] = v;
        }
        return results$;
      }()), {
        safe: true
      });
      params[type + '.' + path] = referencedIdOrIds;
      return this._urlTemplatesParsed[type + '.' + path].expand(params);
    };
    prototype.get = function(){
      var x$, doc, this$ = this;
      x$ = doc = {};
      if (this.meta) {
        x$['meta'] = this.meta;
      }
      x$[this.resources.type] = function(){
        var isCollection, renderedResources;
        isCollection = this$.resources instanceof Collection;
        renderedResources = isCollection
          ? this$.resources.resources.map(bind$(this$, 'renderResource'))
          : this$.renderResource(this$.resources);
        if (isCollection) {
          renderedResources.map(function(it){
            var i$;
            if (it.links != null) {
              for (i$ in it.links) {
                (fn$.call(this$, i$, it.links[i$]));
              }
            }
            return it;
            function fn$(path, link){
              var templateKey;
              templateKey = this.resources.type + '.' + path;
              if (!this.links[templateKey]) {
                this.links[templateKey] = {
                  type: link.type,
                  href: this.urlTemplates[templateKey]
                };
              }
              it.links[path] = it.links[path].ids || it.links[path].id;
            }
          });
        }
        return renderedResources;
      }();
      if (!prelude.Obj.empty(this.linked)) {
        x$['linked'] = this.linked;
      }
      if (!prelude.Obj.empty(this.links)) {
        x$['links'] = this.links;
      }
      return doc;
    };
    return Document;
  }());
  module.exports = Document;
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
}).call(this);
