"use strict";

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { "default": obj }; };

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var co = _interopRequire(require("co"));

var polyfill = _interopRequire(require("babel/polyfill"));

var ResponseContext = _interopRequire(require("./types/Context/ResponseContext"));

var Document = _interopRequire(require("./types/Document"));

var Collection = _interopRequire(require("./types/Collection"));

var APIError = _interopRequire(require("./types/APIError"));

var requestValidators = _interopRequireWildcard(require("./steps/http/validate-request"));

var negotiateContentType = _interopRequire(require("./steps/http/negotiate-content-type"));

var labelToIds = _interopRequire(require("./steps/pre-query/label-to-ids"));

var parseRequestResources = _interopRequire(require("./steps/pre-query/parse-resources"));

var applyTransform = _interopRequire(require("./steps/apply-transform"));

var doFind = _interopRequire(require("./steps/do-query/do-find"));

var doCreate = _interopRequire(require("./steps/do-query/do-create"));

var doUpdate = _interopRequire(require("./steps/do-query/do-update"));

var doDelete = _interopRequire(require("./steps/do-query/do-delete"));

module.exports = function (registry) {
  var supportedExt = ["bulk"];

  /**
   * @param {RequestContext} requestContext The request context that will be
   *    used by the pipeline to generate the ResponseContext for the request.
   * @param {Object} frameworkReq This should be the request object generated by
   *    the framework that you're using. But, really, it can be absolutely
   *    anything, as this pipeline won't use it for anything except passing it
   *    to user-provided functions that it calls (like transforms and id mappers).
   * @param {Object} frameworkRes Theoretically, the response objcet generated
   *     by your http framework but, like with frameworkReq, it can be anything.
   */
  function pipeline(requestContext, frameworkReq, frameworkRes) {
    var responseContext = new ResponseContext();

    // Kick off the chain for generating the response.
    return co(regeneratorRuntime.mark(function callee$2$0() {
      var parsedResources, mappedLabel, mappedIsEmptyArray;
      return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            context$3$0.prev = 0;
            context$3$0.next = 3;
            return requestValidators.checkBodyExistence(requestContext);

          case 3:
            if (!requestContext.hasBody) {
              context$3$0.next = 12;
              break;
            }

            context$3$0.next = 6;
            return requestValidators.checkBodyIsValidJSONAPI(requestContext.body);

          case 6:
            context$3$0.next = 8;
            return requestValidators.checkContentType(requestContext, supportedExt);

          case 8:
            context$3$0.next = 10;
            return parseRequestResources(requestContext.body.data, requestContext.aboutLinkObject);

          case 10:
            parsedResources = context$3$0.sent;

            requestContext.primary = applyTransform(parsedResources, "beforeQuery", registry, frameworkReq, frameworkRes);

          case 12:
            if (!(requestContext.idOrIds && requestContext.allowLabel)) {
              context$3$0.next = 19;
              break;
            }

            context$3$0.next = 15;
            return labelToIds(requestContext.type, requestContext.idOrIds, registry, frameworkReq);

          case 15:
            mappedLabel = context$3$0.sent;

            // set the idOrIds on the request context
            requestContext.idOrIds = mappedLabel;

            mappedIsEmptyArray = Array.isArray(mappedLabel) && !mappedLabel.length;

            if (mappedLabel === null || mappedLabel === undefined || mappedIsEmptyArray) {
              responseContext.primary = mappedLabel ? new Collection() : null;
            }

          case 19:
            if (!(typeof responseContext.primary === "undefined")) {
              context$3$0.next = 34;
              break;
            }

            context$3$0.t0 = requestContext.method;
            context$3$0.next = context$3$0.t0 === "get" ? 23 : context$3$0.t0 === "post" ? 26 : context$3$0.t0 === "patch" ? 29 : context$3$0.t0 === "delete" ? 32 : 34;
            break;

          case 23:
            context$3$0.next = 25;
            return doFind(requestContext, responseContext, registry);

          case 25:
            return context$3$0.abrupt("break", 34);

          case 26:
            context$3$0.next = 28;
            return doCreate(requestContext, responseContext, registry);

          case 28:
            return context$3$0.abrupt("break", 34);

          case 29:
            context$3$0.next = 31;
            return doUpdate(requestContext, responseContext, registry);

          case 31:
            return context$3$0.abrupt("break", 34);

          case 32:
            context$3$0.next = 34;
            return doDelete(requestContext, responseContext, registry);

          case 34:
            context$3$0.next = 40;
            break;

          case 36:
            context$3$0.prev = 36;
            context$3$0.t1 = context$3$0["catch"](0);

            context$3$0.t1 = (Array.isArray(context$3$0.t1) ? context$3$0.t1 : [context$3$0.t1]).map(function (it) {
              if (it instanceof APIError) {
                return it;
              } else {
                var _status = it.status || it.statusCode || 500;
                // if the user can't throw an APIError instance but wants to signal
                // that their specific error message should be used, let them do so.
                var message = it.isJSONAPIDisplayReady ? it.message : "An unknown error occurred while trying to process this request.";

                return new APIError(_status, undefined, message);
              }
            });
            responseContext.errors = responseContext.errors.concat(context$3$0.t1);

          case 40:
            context$3$0.next = 42;
            return negotiateContentType(requestContext.accepts, responseContext.ext, supportedExt);

          case 42:
            responseContext.contentType = context$3$0.sent;

            // apply transforms pre-send
            responseContext.primary = applyTransform(responseContext.primary, "beforeRender", registry, frameworkReq, frameworkRes);

            responseContext.included = applyTransform(responseContext.included, "beforeRender", registry, frameworkReq, frameworkRes);

            if (responseContext.errors.length) {
              responseContext.status = pickStatus(responseContext.errors.map(function (v) {
                return Number(v.status);
              }));
              responseContext.body = new Document(responseContext.errors).get();
            } else {
              responseContext.body = new Document(responseContext.primary, responseContext.included, {}, registry.urlTemplates(), requestContext.uri).get();
            }

            return context$3$0.abrupt("return", responseContext);

          case 47:
          case "end":
            return context$3$0.stop();
        }
      }, callee$2$0, this, [[0, 36]]);
    }));
  }

  pipeline.supportedExt = supportedExt;

  pipeline.responseFromExternalError = function (requestContext, error) {
    var responseContext = new ResponseContext();
    negotiateContentType(requestContext.accepts, [], supportedExt).then(function (contentType) {
      responseContext.contentType = contentType;
      responseContext.status = error.status || 400;
      responseContext.body = new Document([APIError.fromError(error)]).get();
    }, function () {});
  };

  return pipeline;
};

/**
 * Returns the status code that best represents a set of error statuses.
 */
function pickStatus(errStatuses) {
  return errStatuses[0];
}

// throw if the body is supposed to be present but isn't (or vice-versa).

// If the request has a body, validate it and parse its resources.

// Map label to idOrIds, if applicable.
// if our new ids are null/undefined or an empty array, we can set
// the primary resources too! (Note: one could argue that we should
// 404 rather than return null when the label matches no ids.)

// Actually fulfill the request!
// If we've already populated the primary resources, which is possible
// because the label may have mapped to no id(s), we don't need to query.

// Add errors to the responseContext converting them, if necessary, to
// APIError instances first. Might be needed if, e.g., the error was
// unexpected (and so uncaught and not transformed) in one of prior steps
// or the user couldn't throw an APIError for compatibility with other code.

// Negotiate the content type