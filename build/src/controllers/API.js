"use strict";

var _classCallCheck = require("babel-runtime/helpers/class-call-check")["default"];

var _createClass = require("babel-runtime/helpers/create-class")["default"];

var _regeneratorRuntime = require("babel-runtime/regenerator")["default"];

var _interopRequire = require("babel-runtime/helpers/interop-require")["default"];

var _interopRequireWildcard = require("babel-runtime/helpers/interop-require-wildcard")["default"];

var co = _interopRequire(require("co"));

var Response = _interopRequire(require("../types/HTTP/Response"));

var Document = _interopRequire(require("../types/Document"));

var Collection = _interopRequire(require("../types/Collection"));

var APIError = _interopRequire(require("../types/APIError"));

var requestValidators = _interopRequireWildcard(require("../steps/http/validate-request"));

var negotiateContentType = _interopRequire(require("../steps/http/negotiate-content-type"));

var labelToIds = _interopRequire(require("../steps/pre-query/label-to-ids"));

var parseRequestResources = _interopRequire(require("../steps/pre-query/parse-resources"));

var validateRequestResources = _interopRequire(require("../steps/pre-query/validate-resources"));

var applyTransform = _interopRequire(require("../steps/apply-transform"));

var doGET = _interopRequire(require("../steps/do-query/do-get"));

var doPOST = _interopRequire(require("../steps/do-query/do-post"));

var doPATCH = _interopRequire(require("../steps/do-query/do-patch"));

var doDELETE = _interopRequire(require("../steps/do-query/do-delete"));

var supportedExt = ["bulk"];

var APIController = (function () {
  function APIController(registry) {
    _classCallCheck(this, APIController);

    this.registry = registry;
  }

  _createClass(APIController, {
    handle: {

      /**
       * @param {Request} request The Request thic controller will use to generate
       *    the Response.
       * @param {Object} frameworkReq This should be the request object generated by
       *    the framework that you're using. But, really, it can be absolutely
       *    anything, as this controller won't use it for anything except passing it
       *    to user-provided functions that it calls (like transforms and id mappers).
       * @param {Object} frameworkRes Theoretically, the response objcet generated
       *     by your http framework but, like with frameworkReq, it can be anything.
       */

      value: function handle(request, frameworkReq, frameworkRes) {
        var response = new Response();
        var registry = this.registry;

        // Kick off the chain for generating the response.
        return co(_regeneratorRuntime.mark(function callee$2$0() {
          var parsedResources, mappedLabel, mappedIsEmptyArray;
          return _regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
            while (1) switch (context$3$0.prev = context$3$0.next) {
              case 0:
                context$3$0.prev = 0;
                context$3$0.next = 3;
                return requestValidators.checkBodyExistence(request);

              case 3:
                if (!request.hasBody) {
                  context$3$0.next = 14;
                  break;
                }

                context$3$0.next = 6;
                return requestValidators.checkBodyIsValidJSONAPI(request.body);

              case 6:
                context$3$0.next = 8;
                return requestValidators.checkContentType(request, supportedExt);

              case 8:
                context$3$0.next = 10;
                return parseRequestResources(request.body.data, request.aboutLinkObject);

              case 10:
                parsedResources = context$3$0.sent;
                context$3$0.next = 13;
                return validateRequestResources(request.type, parsedResources, registry);

              case 13:

                request.primary = applyTransform(parsedResources, "beforeSave", registry, frameworkReq, frameworkRes);

              case 14:
                if (!(request.idOrIds && request.allowLabel)) {
                  context$3$0.next = 21;
                  break;
                }

                context$3$0.next = 17;
                return labelToIds(request.type, request.idOrIds, registry, frameworkReq);

              case 17:
                mappedLabel = context$3$0.sent;

                // set the idOrIds on the request context
                request.idOrIds = mappedLabel;

                mappedIsEmptyArray = Array.isArray(mappedLabel) && !mappedLabel.length;

                if (mappedLabel === null || mappedLabel === undefined || mappedIsEmptyArray) {
                  response.primary = mappedLabel ? new Collection() : null;
                }

              case 21:
                if (!(typeof response.primary === "undefined")) {
                  context$3$0.next = 36;
                  break;
                }

                context$3$0.t0 = request.method;
                context$3$0.next = context$3$0.t0 === "get" ? 25 : context$3$0.t0 === "post" ? 28 : context$3$0.t0 === "patch" ? 31 : context$3$0.t0 === "delete" ? 34 : 36;
                break;

              case 25:
                context$3$0.next = 27;
                return doGET(request, response, registry);

              case 27:
                return context$3$0.abrupt("break", 36);

              case 28:
                context$3$0.next = 30;
                return doPOST(request, response, registry);

              case 30:
                return context$3$0.abrupt("break", 36);

              case 31:
                context$3$0.next = 33;
                return doPATCH(request, response, registry);

              case 33:
                return context$3$0.abrupt("break", 36);

              case 34:
                context$3$0.next = 36;
                return doDELETE(request, response, registry);

              case 36:
                context$3$0.next = 43;
                break;

              case 38:
                context$3$0.prev = 38;
                context$3$0.t1 = context$3$0["catch"](0);

                console.log(context$3$0.t1, context$3$0.t1.stack, context$3$0.t1[0] ? context$3$0.t1[0].stack : undefined);
                context$3$0.t1 = (Array.isArray(context$3$0.t1) ? context$3$0.t1 : [context$3$0.t1]).map(function (it) {
                  if (it instanceof APIError) {
                    return it;
                  } else {
                    var _status = it.status || it.statusCode || 500;
                    // if the user can't throw an APIError instance but wants to signal
                    // that their specific error message should be used, let them do so.
                    var message = it.isJSONAPIDisplayReady ? it.message : "An unknown error occurred while trying to process this request.";

                    return new APIError(_status, undefined, message);
                  }
                });
                response.errors = response.errors.concat(context$3$0.t1);

              case 43:
                context$3$0.next = 45;
                return negotiateContentType(request.accepts, response.ext, supportedExt);

              case 45:
                response.contentType = context$3$0.sent;

                if (!response.errors.length) {
                  context$3$0.next = 50;
                  break;
                }

                response.status = pickStatus(response.errors.map(function (v) {
                  return Number(v.status);
                }));
                response.body = new Document(response.errors).get(true);
                return context$3$0.abrupt("return", response);

              case 50:

                // apply transforms pre-send
                response.primary = applyTransform(response.primary, "beforeRender", registry, frameworkReq, frameworkRes);

                response.included = applyTransform(response.included, "beforeRender", registry, frameworkReq, frameworkRes);

                if (response.status !== 204) {
                  response.body = new Document(response.primary, response.included, undefined, registry.urlTemplates(), request.uri).get(true);
                }

                return context$3$0.abrupt("return", response);

              case 54:
              case "end":
                return context$3$0.stop();
            }
          }, callee$2$0, this, [[0, 38]]);
        }));
      }
    }
  }, {
    responseFromExternalError: {
      value: function responseFromExternalError(request, error) {
        var response = new Response();
        return negotiateContentType(request.accepts, [], supportedExt).then(function (contentType) {
          response.contentType = contentType;
          response.status = error.status || error.statusCode || 400;
          response.body = new Document([APIError.fromError(error)]).get(true);

          return response;
        }, function () {
          // even if we had an error, return the response.
          // it just won't have a content-type.
          return response;
        });
      }
    }
  });

  return APIController;
})();

APIController.supportedExt = supportedExt;

module.exports = APIController;

/**
 * Returns the status code that best represents a set of error statuses.
 */
function pickStatus(errStatuses) {
  return errStatuses[0];
}

// throw if the body is supposed to be present but isn't (or vice-versa).

// If the request has a body, validate it and parse its resources.

// validate the request resources's type.

// Map label to idOrIds, if applicable.
// if our new ids are null/undefined or an empty array, we can set
// the primary resources too! (Note: one could argue that we should
// 404 rather than return null when the label matches no ids.)

// Actually fulfill the request!
// If we've already populated the primary resources, which is possible
// because the label may have mapped to no id(s), we don't need to query.

// Add errors to the response converting them, if necessary, to
// APIError instances first. Might be needed if, e.g., the error was
// unexpected (and so uncaught and not transformed) in one of prior steps
// or the user couldn't throw an APIError for compatibility with other code.

// Negotiate the content type

// If we have errors, return here and don't bother with transforms.