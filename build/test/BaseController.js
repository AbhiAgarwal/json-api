// Generated by LiveScript 1.2.0
(function(){
  var mocha, sinon, chai, bodyParser, Q, supertest, express, BaseController, ErrorResource, Collection, ResourceTypeRegistry, expect, it2, app, adapter, registry, Base, getSpy, request;
  mocha = require('mocha');
  sinon = require('sinon');
  chai = require('chai');
  bodyParser = require('body-parser');
  Q = require('Q');
  supertest = require('supertest');
  express = require('express');
  BaseController = require('../lib/BaseController');
  ErrorResource = require('../lib/types/ErrorResource');
  Collection = require('../lib/types/Collection');
  ResourceTypeRegistry = require('../lib/ResourceTypeRegistry');
  expect = chai.expect;
  it2 = it;
  app = express();
  adapter = {
    find: sinon.stub().returns(Q.fcall(function(){
      throw new Error("Blah");
    }))
  };
  registry = {
    adapter: sinon.stub().returns(adapter),
    urlTemplates: sinon.stub().returns({
      "people.something": "something/{people.id}",
      "user.person": "people/{person.id}"
    }),
    afterQuery: sinon.spy(function(){
      return function(it){
        return it;
      };
    }),
    beforeSave: sinon.spy(function(){
      return function(it){
        return it;
      };
    }),
    defaultIncludes: sinon.stub().returns(undefined)
  };
  Base = new BaseController(registry);
  getSpy = sinon.spy(bind$(Base, 'GET'));
  app.get("/:type/:id?", getSpy);
  request = supertest(app);
  describe("Base Controller", function(){
    describe("GET", function(){
      it2("should be a standard middleware function", function(){
        return expect(Base.GET).to.be.a('function')['with'].length(3);
      });
      describe("finding resources through the adapter", function(){
        var urlsToFindOptions, url, options, results$ = [];
        beforeEach(function(){
          adapter.find.reset();
          return registry.adapter.reset();
        });
        urlsToFindOptions = {
          '/mytypes': ['mytypes', void 8, {}, void 8, void 8, void 8],
          '/mytypes/1': ['mytypes', '1', {}, void 8, void 8, void 8],
          '/mytypes/1,2': ['mytypes', ['1', '2'], {}, void 8, void 8, void 8],
          '/mytypes/test%252Cit%2Cextra': ['mytypes', ['test,it', 'extra'], {}, void 8, void 8, void 8],
          '/mytypes/1?sort=test': ['mytypes', '1', {}, void 8, ['test'], void 8],
          '/mytypes/1?sort=a,b': ['mytypes', '1', {}, void 8, ['a', 'b'], void 8],
          '/mytypes?sort=test%252Cit%2Cextra': ['mytypes', void 8, {}, void 8, ['test,it', 'extra'], void 8],
          '/mytypes?sort=a&include=bob&date=now': [
            'mytypes', void 8, {
              'date': 'now'
            }, void 8, ['a'], ['bob']
          ]
        };
        for (url in urlsToFindOptions) {
          options = urlsToFindOptions[url];
          results$.push(fn$(url, options));
        }
        return results$;
        function fn$(url, options){
          return it2("a request for " + url + " should make the right call", function(done){
            return request.get(url).end(function(){
              expect(registry.adapter.calledOnce).to.be['true'];
              expect(registry.adapter.calledWith("mytypes")).to.be['true'];
              expect(adapter.find.calledOnce).to.be['true'];
              expect(adapter.find.firstCall.args).to.deep.equal(options);
              return done();
            });
          });
        }
      });
      return it2.skip("should run afterQuery recursively on the found resources", function(){});
    });
    describe("sendResources", function(){
      it2.skip("uses the error's status as response status code if passed an error resource", function(){
        BaseController.sendResources(resSpy, new ErrorResource(null, {
          'status': 411
        }));
        BaseController.sendResources(resSpy, new ErrorResource(null, {
          'status': 408
        }));
        expect(resSpy.json.firstCall.args).to.have.length(2);
        expect(resSpy.json.secondCall.args).to.have.length(2);
        expect(resSpy.json.firstCall.args[0]).to.equal(411);
        expect(resSpy.json.secondCall.args[0]).to.equal(408);
        return expect(resSpy.json.firstCall.args[1]).to.be.an("object");
      });
      it2.skip("should send the response with the proper mime type", function(){
        BaseController.sendResources(resSpy, new ErrorResource(null, {
          'status': 408
        }));
        return expect(resSpy.set.calledWith("Content-Type", "application/vnd.api+json")).to.be['true'];
      });
      return it2.skip("calls `pickStatus` to figure out the appopriate response status code if passed a collection of error resources", function(){
        var coll, pickStatusSpy;
        coll = new Collection([
          new ErrorResource(null, {
            'status': 411
          }), new ErrorResource(null, {
            'status': 408
          })
        ]);
        pickStatusSpy = sinon.spy(BaseController, "_pickStatus");
        BaseController.sendResources(resSpy, coll);
        expect(pickStatusSpy.callCount).to.equal(1);
        expect(pickStatusSpy.calledWith([411, 408])).to.be['true'];
        expect(resSpy.json.firstCall.args).to.have.length(2);
        expect(resSpy.json.firstCall.args[1]).to.be.an("object");
        return BaseController._pickStatus.restore();
      });
    });
    describe("getBodyPromise", function(){
      var parser;
      parser = bodyParser.json({
        type: ['json', 'application/vnd.api+json']
      });
      it2.skip("promises req.body if that's already an object", function(done){
        var body;
        body = {};
        return BaseController.getBodyPromise({
          body: body
        }, {}, parser).then(function(it){
          expect(it).to.equal(body);
          return done();
        });
      });
      it2.skip("sends a 415 error for invalid character encodings", function(){});
      it2.skip("sends a 400 error that says resource is required for an empty json body", function(){});
      return it2.skip("sends a 400 invalid json error for any other json syntax errors", function(){});
    });
    return describe("", function(){});
  });
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
}).call(this);
